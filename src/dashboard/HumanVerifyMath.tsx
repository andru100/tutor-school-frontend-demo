import React, { useState, useEffect, useRef } from 'react';
import { Question, VerificationStatus } from './types.tsx';
import CodeBox from './CodeBox.tsx'
import toast from 'react-hot-toast';
import { BackButton } from './BackButton.tsx';

interface Props {
  goBackToDash: () => void; 
}

const HumanVerifyMath: React.FC<Props> = ({  goBackToDash }) => {
  const [selectedExam, setSelectedExam] = useState<number | null>(null);
  const [selectedTopic, setSelectedTopic] = useState<string | null>(null);
  const [selectedQuestion, setSelectedQuestion] = useState<Question | null>(null);
  const [flagNote, setFlagNote] = useState<string>('');
  const [questions, setQuestions] = useState<Question[]>([]);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const accessToken = localStorage.getItem('accessToken') || null;
        const serverAddress = import.meta.env.VITE_APP_BACKEND_ADDRESS

        const response = await fetch( serverAddress + "/api/query/getVerifyQuestions", {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          }
        });

        if (response.status === 401  || response.status === 404 || response.status === 403) {
          toast.error("error retrieving exams")
          console.log("Error fetching questions data:", response.status);
          goBackToDash()
        } else {
          const data = await response.json();
          console.log("successfuly retrieved exams, response data is: ", data);
          setQuestions(data);
        }
      } catch (error) {
        toast.error('unable to retrieve exams')
        console.error("Error fetching exam and questions data:", error);
      }
    };

    fetchData();
  }, []);

  const handleExamSelect = (examId: number) => {
    setSelectedExam(examId);
    setSelectedTopic(null);
    setSelectedQuestion(null);
  };

  const handleTopicSelect = (topic: string) => {
    setSelectedTopic(topic);
    setSelectedQuestion(null);
  };

  const handleQuestionSelect = (question: Question) => {
    setSelectedQuestion(question);
  }; 

  const handleAltQuestionSelect = (altQuestion: Question) => {
    setSelectedQuestion(altQuestion);
  };

  const handleVerify = async (question: Question) => {

    question.verificationStatus = VerificationStatus.Verified;
    question.verifiedHumanFeedback.push({
      id: Math.random(), 
      questionBankId: question.id!,
      isVerified: true,
      verifierId: 'user-id', 
      verificationDate: new Date(),
      notes: '',
    });

    try {
      const response = await fetch('/api/verify-question', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(question),
      });

      if (response.status === 200) {
        toast.success("Verification successful");
        console.log("Verification successful, response code: ", response.status);
      } else {
        toast.error("Verification failed");
        console.error("Error verifying question, response code: ", response.status);
      }
    } catch (error) {
      toast.error('An error occurred during verification');
      console.error("Error verifying question:", error);
    }
  };
  

  const handleFlag = async (question: Question) => {
    question.verificationStatus = VerificationStatus.FlaggedForReview;
    question.verifiedHumanFeedback.push({
      id: Math.random(), 
      questionBankId: question.id!,
      isVerified: false,
      verifierId: 'user-id', 
      verificationDate: new Date(),
      notes: flagNote, 
    });

    try {
      const response = await fetch('/api/update-question', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(question),
      });

      if (response.status === 200) {
        toast.success("Flagging successful");
        console.log("Flagging successful, response code: ", response.status);
        setFlagNote('');
      } else {
        toast.error("Flagging failed");
        console.error("Error flagging question, response code: ", response.status);
      }
    } catch (error) {
      toast.error('An error occurred during flagging');
      console.error("Error flagging question:", error);
    }
  };


  const handleDelete = async (question: Question) => {
    try{
      question.verificationStatus = VerificationStatus.Rejected;
      question.verifiedHumanFeedback.push({
        id: Math.random(), // will be generated by postgresql
        questionBankId: question.id!,
        isVerified: false,
        verifierId: 'user-id', // will be Replaced with actual user ID from auth
        verificationDate: new Date(),
        notes: 'Question deleted', // Add a note indicating question deletion
      });

      // Send updated question to API
      const response = await fetch('/api/update-question', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(question),
      });

      if (response.status === 200) {
        toast.success("Generation successful");
        console.log("Generation successful, response code: ", response.status);
      } else {
        toast.error("Unable to delete question");
        console.error("Error deleting question, response code: ", response.status);
      } 
    }catch (error) {
      toast.error('An error occurred');
      console.error("Error occured in handleDelete:", error);
    }
  };

  const handleGenerate = async (questionId: number) => {
    try {
      const serverAddress = import.meta.env.VITE_APP_BACKEND_ADDRESS

      const response = await fetch( serverAddress + "/api/mutation/GenerateQuestion", {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ id: questionId })
      });
  
      if (response.ok) {
        const updatedQuestions = await response.json();
        setQuestions(updatedQuestions);
        toast.success("Generation successful");
      } else {
        toast.error("Generation failed");
        console.error("Error generating question, response code: ", response.status);
      }
    } catch (error) {
      toast.error('An error occurred');
      console.error('Error generating questions:', error);
    }
  };

  function CodeBlockWithCopyButton() {
    const codeRef = useRef(null);
  
    const copyToClipboard = (e) => {
      if (codeRef.current && codeRef.current.innerText) {
        navigator.clipboard.writeText(codeRef.current.innerText)
          .then(() => alert('Code copied to clipboard!'))
          .catch((err) => console.error('Could not copy text: ', err));
      }
    };
  
    return (
      <div>
        <button style={{backgroundColor: 'blue', color: 'white'}} onClick={copyToClipboard}>Copy</button>
       <CodeBox language="python" code={selectedQuestion && selectedQuestion.code ? selectedQuestion.code : 'No code available'} />
      </div>
    );
  }
  

  // Get unique exams and topics
  const exams = [...new Set(questions.map((question) => question.assessmentId))];
  const topics = [...new Set(questions.map((question) => question.topic))];


  return (
    <div className="grid grid-rows-2 gap-4">
      <BackButton goBackToDash={goBackToDash}/>
      <div className="grid grid-cols-5 gap-1">
        {/* First row with four columns */}
        <div className="p-4">
          {exams.map((examId) => (
            <div className="my-2">
              <button 
                key={examId} 
                className={`inline-block rounded bg-danger px-6 pb-2 pt-2.5 text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#dc4c64] transition duration-150 ease-in-out hover:bg-danger-600 hover:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.3),0_4px_18px_0_rgba(220,76,100,0.2)] focus:bg-danger-600 focus:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.3),0_4px_18px_0_rgba(220,76,100,0.2)] focus:outline-none focus:ring-0 active:bg-danger-700 active:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.3),0_4px_18px_0_rgba(220,76,100,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(220,76,100,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.2),0_4px_18px_0_rgba(220,76,100,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.2),0_4px_18px_0_rgba(220,76,100,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.2),0_4px_18px_0_rgba(220,76,100,0.1)]`}
                onClick={() => handleExamSelect(examId)}
              >
                {examId}
              </button>
            </div>
          ))}
        </div>
        {selectedExam && (
          <div className="p-4">
            {topics
              .filter((topic) => questions.find(question => question.assessmentId === selectedExam && question.topic === topic))
              .map((topic) => (
                <div className="my-2">
                  <button 
                    key={topic} 
                    className={`inline-block rounded bg-danger px-6 pb-2 pt-2.5 text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#dc4c64] transition duration-150 ease-in-out hover:bg-danger-600 hover:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.3),0_4px_18px_0_rgba(220,76,100,0.2)] focus:bg-danger-600 focus:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.3),0_4px_18px_0_rgba(220,76,100,0.2)] focus:outline-none focus:ring-0 active:bg-danger-700 active:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.3),0_4px_18px_0_rgba(220,76,100,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(220,76,100,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.2),0_4px_18px_0_rgba(220,76,100,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.2),0_4px_18px_0_rgba(220,76,100,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(220,76,100,0.2),0_4px_18px_0_rgba(220,76,100,0.1)]`}
                    onClick={() => handleTopicSelect(topic)}
                  >
                    {topic}
                  </button>
                </div>
              ))}
          </div>
        )}
        {selectedTopic && (
          <div className="p-4">
            {questions
              .filter((question) => question.topic === selectedTopic)
              .map((question) => (
                <div className="my-2">
                  <button 
                    key={question.questionText} 
                    className={`inline-block rounded bg-warning px-6 pb-2 pt-2.5 text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#e4a11b] transition duration-150 ease-in-out hover:bg-warning-600 hover:shadow-[0_8px_9px_-4px_rgba(228,161,27,0.3),0_4px_18px_0_rgba(228,161,27,0.2)] focus:bg-warning-600 focus:shadow-[0_8px_9px_-4px_rgba(228,161,27,0.3),0_4px_18px_0_rgba(228,161,27,0.2)] focus:outline-none focus:ring-0 active:bg-warning-700 active:shadow-[0_8px_9px_-4px_rgba(228,161,27,0.3),0_4px_18px_0_rgba(228,161,27,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(228,161,27,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(228,161,27,0.2),0_4px_18px_0_rgba(228,161,27,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(228,161,27,0.2),0_4px_18px_0_rgba(228,161,27,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(228,161,27,0.2),0_4px_18px_0_rgba(228,161,27,0.1)]`}
                    onClick={() => handleQuestionSelect(question)}
                  >
                    {question.questionText}
                  </button>
                </div>
              ))}
          </div>
        )}
        {selectedQuestion && (
          <div className="p-4">
            <div className="my-2">
              <button 
                className={`inline-block rounded bg-info px-6 pb-2 pt-2.5 text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#54b4d3] transition duration-150 ease-in-out hover:bg-info-600 hover:shadow-[0_8px_9px_-4px_rgba(84,180,211,0.3),0_4px_18px_0_rgba(84,180,211,0.2)] focus:bg-info-600 focus:shadow-[0_8px_9px_-4px_rgba(84,180,211,0.3),0_4px_18px_0_rgba(84,180,211,0.2)] focus:outline-none focus:ring-0 active:bg-info-700 active:shadow-[0_8px_9px_-4px_rgba(84,180,211,0.3),0_4px_18px_0_rgba(84,180,211,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(84,180,211,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(84,180,211,0.2),0_4px_18px_0_rgba(84,180,211,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(84,180,211,0.2),0_4px_18px_0_rgba(84,180,211,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(84,180,211,0.2),0_4px_18px_0_rgba(84,180,211,0.1)]`}
              >
                {selectedQuestion.questionText}
              </button>
            </div>
            {selectedQuestion.answerOptions.map((option, index) => (
              <div className="my-2">
                <button 
                  className={`inline-block rounded px-6 pb-2 pt-2.5 text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#54b4d3] transition duration-150 ease-in-out focus:outline-none focus:ring-0 ${option.isCorrect ? 'bg-success' : 'bg-danger'}`}
                >
                  {index + 1}. {option.answerText}
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
      <div className="grid grid-cols-3 gap-4">
        {/* Second row with three columns */}
        <div className="p-4">
          <CodeBlockWithCopyButton  />
        </div>
        {selectedQuestion && selectedQuestion.derivedQuestions && selectedQuestion.derivedQuestions.length > 0 ? 
          selectedQuestion.derivedQuestions.map((altQuestion, index) => (
            <div className="my-2">
              <button 
                key={index} 
                className={``}
                onClick={() => handleAltQuestionSelect(altQuestion)}
              >
                {altQuestion.questionText}
              </button>
            </div>
          )) : 
          <div className="my-2">
            No alt questions
          </div>
        }
        {selectedQuestion && (
          <div className="p-4">
            {/* Question verification section */}
            <div className="my-2">
              <button 
                className={``}
                onClick={() => handleVerify(selectedQuestion)}
              >
                Verify
              </button>
            </div>
            <div className="my-2">
              <button 
                className={``}
                onClick={() => handleFlag(selectedQuestion)}
              >
                Flag
              </button>
            </div>
            <div className="my-2">
              <button 
                className={``}
                onClick={() => handleDelete(selectedQuestion)}
              >
                Delete
              </button>
            </div>
            <div className="my-2">
              <button 
                className={``}
                onClick={() => handleGenerate(selectedQuestion.id)}
              >
                Generate
              </button>
            </div>
          </div>
        )}

    </div>
  </div>
  );
};

export default HumanVerifyMath;



